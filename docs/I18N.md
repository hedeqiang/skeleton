# 国际化 (i18n) 多语言支持

本文档介绍如何在项目中使用国际化功能，支持多语言切换。

## 📋 目录

- [概述](#概述)
- [快速开始](#快速开始)
- [配置说明](#配置说明)
- [API 使用](#api-使用)
- [消息文件管理](#消息文件管理)
- [错误消息国际化](#错误消息国际化)
- [中间件使用](#中间件使用)
- [最佳实践](#最佳实践)
- [故障排除](#故障排除)

## 概述

项目采用了现代化的 i18n 解决方案：

- **核心库**: `nicksnyder/go-i18n/v2` - Go 生态最主流的国际化库
- **语言处理**: `golang.org/x/text/language` - 官方语言标签处理
- **消息格式**: YAML - 易读易维护的消息文件格式
- **架构集成**: 完整的 Wire 依赖注入支持

### 支持的语言

- 🇨🇳 **中文** (`zh`) - 默认语言
- 🇺🇸 **英文** (`en`) - 备用语言

## 快速开始

### 1. 基本配置

配置文件 `configs/config.dev.yaml`:

```yaml
i18n:
  default_language: "zh"           # 默认语言
  support_languages: ["zh", "en"] # 支持的语言列表
  messages_path: "./locales"       # 消息文件路径
  accept_languages: ["zh", "zh-CN", "zh-Hans", "en", "en-US"]
```

### 2. 在代码中使用

```go
// 在 Handler 中获取 i18n 实例
func (h *UserHandler) GetUser(c *gin.Context) {
    // 从 context 获取用户语言偏好，自动翻译
    message := h.app.I18n.T(c.Request.Context(), "api.user.created", nil)
    
    // 带参数的消息翻译
    welcome := h.app.I18n.T(c.Request.Context(), "common.hello", 
        map[string]interface{}{"Name": "张三"})
    
    c.JSON(200, gin.H{"message": message, "welcome": welcome})
}
```

### 3. 客户端语言切换

```bash
# 通过 HTTP Header 设置语言
curl -H "Accept-Language: zh-CN,zh;q=0.9" http://localhost:8080/api/users

# 通过查询参数设置语言  
curl http://localhost:8080/api/users?lang=en
```

## 配置说明

### I18n 配置结构

```go
type I18nConfig struct {
    DefaultLanguage   string   // 默认语言代码
    SupportLanguages  []string // 支持的语言代码列表
    MessagesPath      string   // 消息文件存放路径
    AcceptLanguages   []string // Accept-Language 支持的语言标签
}
```

### 配置选项详解

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `default_language` | string | `"zh"` | 默认语言，当检测不到用户语言时使用 |
| `support_languages` | []string | `["zh", "en"]` | 应用支持的语言列表 |
| `messages_path` | string | `"./locales"` | 消息文件存放的目录路径 |
| `accept_languages` | []string | 见配置文件 | Accept-Language header 识别的语言标签 |

### 环境配置

可通过环境变量覆盖配置：

```bash
# 设置默认语言为英文
export I18N_DEFAULT_LANGUAGE=en

# 设置消息文件路径
export I18N_MESSAGES_PATH=/app/locales
```

## API 使用

### 核心接口

```go
type I18n struct {
    // 私有字段...
}

// 主要方法
func (i *I18n) T(ctx context.Context, messageID string, templateData map[string]interface{}) string
func (i *I18n) TWithLang(lang, messageID string, templateData map[string]interface{}) string
func (i *I18n) GetLocalizer(lang string) *i18n.Localizer
```

### 使用示例

#### 基础翻译

```go
// 简单消息翻译
message := i18n.T(ctx, "errors.user_not_found", nil)

// 带模板变量的翻译
greeting := i18n.T(ctx, "common.hello", map[string]interface{}{
    "Name": "Alice",
})
```

#### 指定语言翻译

```go
// 直接指定语言翻译，不依赖 context
zhMessage := i18n.TWithLang("zh", "common.welcome", nil)
enMessage := i18n.TWithLang("en", "common.welcome", nil)
```

#### Context 语言管理

```go
// 设置语言到 context
ctx := i18n.SetLanguageToContext(context.Background(), "en")

// 从 context 获取语言
lang := i18n.GetLanguageFromContext(ctx) // 返回 "en"
```

#### Accept-Language 解析

```go
// 解析 HTTP Accept-Language header
lang := i18n.ParseAcceptLanguage("zh-CN,zh;q=0.9,en;q=0.8")
// 返回: "zh"

lang = i18n.ParseAcceptLanguage("en-US,en;q=0.9")  
// 返回: "en"

lang = i18n.ParseAcceptLanguage("fr-FR,fr;q=0.9")
// 返回: "zh" (不支持的语言返回默认语言)
```

## 消息文件管理

### 文件结构

```
locales/
├── zh.yaml    # 中文消息
└── en.yaml    # 英文消息
```

### 消息文件格式

#### 中文消息文件 (`locales/zh.yaml`)

```yaml
# 错误消息
errors:
  user_not_found:
    other: "用户不存在"
  user_exists:
    other: "用户已存在" 
  invalid_password:
    other: "密码错误"

# 通用消息
common:
  success:
    other: "操作成功"
  hello:
    one: "你好 {{.Name}}"
    other: "你好 {{.Name}}"
  welcome:
    other: "欢迎！"

# API 响应消息
api:
  user:
    created:
      other: "用户创建成功"
    updated:
      other: "用户更新成功"

# 验证消息
validation:
  required:
    other: "{{.Field}}是必填项"
  min_length:
    other: "{{.Field}}最少需要{{.Min}}个字符"
```

#### 英文消息文件 (`locales/en.yaml`)

```yaml
# Error messages
errors:
  user_not_found:
    other: "User not found"
  user_exists:
    other: "User already exists"
  invalid_password:
    other: "Invalid password"

# Common messages  
common:
  success:
    other: "Operation successful"
  hello:
    one: "Hello {{.Name}}"
    other: "Hello {{.Name}}"
  welcome:
    other: "Welcome!"

# API response messages
api:
  user:
    created:
      other: "User created successfully"
    updated:
      other: "User updated successfully"

# Validation messages
validation:
  required:
    other: "{{.Field}} is required"
  min_length:
    other: "{{.Field}} must be at least {{.Min}} characters"
```

### 消息键命名规范

- 使用 `.` 分隔的层级结构
- 采用 `snake_case` 命名风格
- 按功能模块分组（errors、common、api、validation 等）

```yaml
# ✅ 推荐的命名方式
errors.user_not_found
api.user.created  
validation.required

# ❌ 不推荐的命名方式
ErrorUserNotFound
api_user_created
validation-required
```

### 复数形式支持

```yaml
# 支持 CLDR 复数规则
items_count:
  one: "{{.Count}} item"
  other: "{{.Count}} items"
  
# 中文通常不区分复数
items_count:
  other: "{{.Count}} 个项目"
```

## 错误消息国际化

### 错误结构扩展

项目的错误类型已经扩展支持国际化：

```go
type AppError struct {
    Type      ErrorType              `json:"type"`
    Message   string                 `json:"message"`
    Code      int                    `json:"code"`
    Err       error                  `json:"-"`
    Details   string                 `json:"details,omitempty"`
    MessageID string                 `json:"-"` // i18n 消息键
    Data      map[string]interface{} `json:"-"` // 模板数据
}
```

### 创建国际化错误

```go
// 创建支持 i18n 的错误
err := errors.NewI18n(errors.ErrorTypeValidation, "validation.required", 
    map[string]interface{}{"Field": "username"})

// 包装现有错误为 i18n 错误
err = errors.WrapI18n(originalErr, errors.ErrorTypeDatabase, 
    "errors.database_error", nil)
```

### 预定义错误

```go
// 所有预定义错误已支持 i18n
var (
    ErrUserNotFound     = NewI18n(ErrorTypeNotFound, "errors.user_not_found", nil)
    ErrUserExists       = NewI18n(ErrorTypeConflict, "errors.user_exists", nil)
    ErrInvalidPassword  = NewI18n(ErrorTypeUnauthorized, "errors.invalid_password", nil)
    // ... 更多错误
)
```

### 错误本地化

```go
// 在 Handler 中返回本地化错误消息
func (h *UserHandler) GetUser(c *gin.Context) {
    user, err := h.userService.GetUser(c.Request.Context(), userID)
    if err != nil {
        if appErr, ok := err.(*errors.AppError); ok {
            // 获取本地化错误消息
            localizedMsg := appErr.LocalizedMessage(c.Request.Context(), h.app.I18n)
            c.JSON(appErr.StatusCode(), gin.H{
                "error": localizedMsg,
                "code":  appErr.Code,
            })
            return
        }
    }
    
    c.JSON(200, user)
}
```

## 中间件使用

### i18n 中间件功能

自动语言检测中间件提供以下功能：

1. **Accept-Language Header 解析** - 自动解析客户端语言偏好
2. **查询参数支持** - 支持 `?lang=en` 参数覆盖
3. **Context 注入** - 将语言信息注入到请求 context
4. **响应头设置** - 设置 `Content-Language` 响应头

### 中间件注册

```go
// 在 router/router.go 中自动注册
func setupMiddleware(r *gin.Engine, logger *zap.Logger, i18n *i18n.I18n) {
    r.Use(middleware.RequestID())
    r.Use(middleware.NewLogger(logger))
    r.Use(middleware.NewRecovery(logger))
    r.Use(middleware.CORS())
    r.Use(middleware.NewI18n(i18n)) // i18n 中间件
}
```

### 语言检测优先级

1. **查询参数** (`?lang=en`) - 最高优先级
2. **Accept-Language Header** - 次优先级
3. **默认语言** - 兜底方案

```bash
# 优先级示例
curl -H "Accept-Language: zh-CN" "http://localhost:8080/api?lang=en"
# 结果：使用英文 (查询参数优先)

curl -H "Accept-Language: en-US" http://localhost:8080/api  
# 结果：使用英文 (Header 生效)

curl http://localhost:8080/api
# 结果：使用中文 (默认语言)
```

## 最佳实践

### 1. 消息文件组织

```yaml
# ✅ 推荐：按功能模块分组
errors:
  authentication:
    invalid_credentials: "..."
    token_expired: "..."
  validation:
    required_field: "..."
    invalid_format: "..."

api:
  user:
    created: "..."
    updated: "..."
  order:
    placed: "..."
    cancelled: "..."

# ❌ 不推荐：扁平化结构
user_created: "..."
order_placed: "..."
validation_error: "..."
```

### 2. 模板变量使用

```yaml
# ✅ 推荐：使用有意义的变量名
welcome_message:
  other: "欢迎 {{.UserName}}，您有 {{.MessageCount}} 条新消息"

# ❌ 不推荐：使用无意义的变量名  
welcome_message:
  other: "欢迎 {{.Arg1}}，您有 {{.Arg2}} 条新消息"
```

### 3. 错误处理

```go
// ✅ 推荐：使用 i18n 错误
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) error {
    if req.Username == "" {
        return errors.NewI18n(errors.ErrorTypeValidation, "validation.required", 
            map[string]interface{}{"Field": "用户名"})
    }
    return nil
}

// ❌ 不推荐：硬编码错误消息
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) error {
    if req.Username == "" {
        return errors.New("用户名不能为空")
    }
    return nil
}
```

### 4. Handler 中的使用

```go
// ✅ 推荐：统一的响应格式
func (h *UserHandler) CreateUser(c *gin.Context) {
    // ... 业务逻辑
    
    successMsg := h.app.I18n.T(c.Request.Context(), "api.user.created", nil)
    c.JSON(201, gin.H{
        "message": successMsg,
        "data":    user,
    })
}
```

### 5. 消息键管理

```go
// ✅ 推荐：定义常量避免拼写错误
const (
    MsgUserCreated    = "api.user.created"
    MsgUserNotFound   = "errors.user_not_found"
    MsgValidationReq  = "validation.required"
)

func (h *UserHandler) CreateUser(c *gin.Context) {
    msg := h.app.I18n.T(c.Request.Context(), MsgUserCreated, nil)
    // ...
}
```

### 6. 新增语言支持

添加新语言支持的步骤：

1. **更新配置**:
```yaml
i18n:
  support_languages: ["zh", "en", "ja"] # 添加日文
```

2. **创建消息文件**:
```bash
touch locales/ja.yaml
```

3. **翻译消息**:
```yaml
# locales/ja.yaml
common:
  welcome:
    other: "いらっしゃいませ！"
```

4. **测试**:
```bash
curl -H "Accept-Language: ja" http://localhost:8080/api
```

## 故障排除

### 常见问题

#### 1. 消息未翻译，显示消息键

**问题**: 返回 `errors.user_not_found` 而不是翻译后的消息

**解决方案**:
- 检查消息文件是否存在对应的键
- 确认 YAML 格式正确（注意缩进）
- 验证消息文件路径配置

```bash
# 检查消息文件
ls -la locales/
cat locales/zh.yaml | grep user_not_found
```

#### 2. 语言检测不生效

**问题**: 设置了 Accept-Language 但仍使用默认语言

**解决方案**:
- 确认中间件已正确注册
- 检查 Accept-Language 格式
- 查看配置中的 `accept_languages` 列表

```bash
# 调试语言检测
curl -v -H "Accept-Language: en-US,en;q=0.9" http://localhost:8080/api
# 检查响应头中的 Content-Language
```

#### 3. 构建失败

**问题**: Wire 生成失败或编译错误

**解决方案**:
```bash
# 重新生成 Wire 代码
make wire

# 检查依赖
go mod tidy

# 重新构建
make build
```

#### 4. 消息文件加载失败

**问题**: 启动时报告无法加载消息文件

**解决方案**:
- 检查文件路径和权限
- 确认 YAML 语法正确
- 查看日志中的详细错误信息

```bash
# 验证 YAML 语法
yamllint locales/zh.yaml

# 检查文件权限
ls -la locales/
```

### 调试技巧

#### 1. 启用详细日志

```go
// 在开发环境启用 debug 日志
logger.Debug("I18n translation", 
    zap.String("messageID", messageID),
    zap.String("language", lang),
    zap.Any("templateData", templateData))
```

#### 2. 测试特定语言

```go
// 创建测试函数验证翻译
func TestI18nTranslation(t *testing.T) {
    i18n, err := i18n.New(i18n.Config{
        DefaultLanguage: "zh",
        SupportLangs:    []string{"zh", "en"},
        MessagesPath:    "./locales",
    })
    require.NoError(t, err)
    
    ctx := i18n.SetLanguageToContext(context.Background(), "zh")
    msg := i18n.T(ctx, "errors.user_not_found", nil)
    assert.Equal(t, "用户不存在", msg)
}
```

#### 3. 验证消息完整性

```bash
# 比较两个语言文件的键是否一致
diff <(grep -E '^[[:space:]]*[^#].*:' locales/zh.yaml | sed 's/:.*//') \
     <(grep -E '^[[:space:]]*[^#].*:' locales/en.yaml | sed 's/:.*//') 
```

### 性能优化

#### 1. 消息预加载

消息文件在启动时一次性加载到内存，运行时无 IO 开销。

#### 2. 本地化器缓存

每种语言的 Localizer 实例会被缓存，避免重复创建。

#### 3. Context 传递优化

语言信息存储在 Context 中，避免频繁解析 HTTP Header。

---

## 总结

本项目的 i18n 实现提供了完整的多语言支持，具有以下特点：

- 🚀 **易于使用** - 简洁的 API 和中间件自动处理
- 🔧 **灵活配置** - 支持多种配置方式和环境变量
- 📁 **结构化消息** - 层级化的消息组织和管理
- 🌐 **标准兼容** - 符合 HTTP Accept-Language 标准
- ⚡ **高性能** - 内存缓存和预加载优化
- 🔍 **易于调试** - 完善的日志和错误处理

通过遵循本文档的指导，您可以轻松地为应用添加多语言支持，提供更好的国际化用户体验。